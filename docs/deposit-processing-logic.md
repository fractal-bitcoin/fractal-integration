# Deposit Processing Logic for Fractal

## 1. Introduction

This document provides a detailed guide for exchanges, wallets, and other platforms on how to reliably process user deposits for fractal. It outlines the logic for synchronizing with the blockchain via node interfaces, identifying relevant incoming transactions, tracking their confirmation status, handling potential blockchain reorganizations (reorgs), and securely crediting user accounts.

This process relies on interacting with a trusted, fully synchronized fractal node using its Remote Procedure Call (RPC) interface.

## 2. Prerequisites

- **Running Node:** A fully synchronized, stable, and trusted instance of the fractal node software (`fractald`).
- **RPC Access:** Configured RPC access to the node (username, password, host, port). Ensure the connection is secure (e.g., via localhost or SSH tunnel if remote).
- **Managed Addresses:** A database or list of all deposit addresses generated by the platform for its users.

## 3. Core Logic Overview

The deposit processing logic involves these main steps:

1.  **Monitor New Blocks:** Continuously check for new blocks added to the blockchain tip.
2.  **Scan Block Transactions:** For each new block, retrieve its full content, including all transactions.
3.  **Identify Relevant Outputs:** Iterate through each transaction's outputs (`vout`) and check if the recipient address matches any of the platform's managed deposit addresses.
4.  **Record Potential Deposits:** If a relevant output is found, record the transaction details (txid, vout index, amount, address, block hash, block height) in a temporary or processing database, marking it as "unconfirmed" or with 1 confirmation.
5.  **Track Confirmations:** As subsequent blocks are added, increment the confirmation count for previously recorded potential deposits.
6.  **Credit User Account:** Once a deposit reaches the platform's required confirmation threshold (e.g., 6 confirmations), mark it as "confirmed" and credit the corresponding user's account balance within the platform's main database.
7.  **Handle Reorganizations:** Implement logic to detect and handle blockchain reorganizations, invalidating deposits from orphaned blocks and re-evaluating confirmations based on the new main chain.

## 4. Detailed Step-by-Step Logic

### Step 4.1: Monitoring for New Blocks

The platform needs a mechanism to detect when a new block is added to the chain. Common methods include:

- **Polling:** Periodically call the `getbestblockhash` RPC command. If the returned hash is different from the last processed hash, a new block (or blocks) has arrived.
- **Node Notifications (Recommended):** Use the node's ZeroMQ (ZMQ) interface (if available and enabled) to subscribe to `hashblock` notifications. This provides instant notification without constant polling.

### Step 4.2: Retrieving and Scanning Block Data

Once a new block hash is detected (e.g., `new_block_hash`):

1.  Call `getblock <new_block_hash> 2` (verbosity level 2) to retrieve the block data including fully decoded transactions. Level 2 provides detailed JSON output.
    ```json
    // Example RPC Call
    // curl --user user:pass --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getblock", "params": ["<new_block_hash>", 2] }' -H 'content-type: text/plain;' http://127.0.0.1:rpcport/
    ```
2.  Parse the JSON response. Note the `height` and the `tx` array containing the list of transactions in this block.

### Step 4.3: Identifying Relevant Transactions and Outputs

Iterate through each `transaction` object within the `tx` array obtained in the previous step:

1.  For each `transaction`, iterate through its `vout` array (list of outputs).
2.  For each `output` in `vout`:
    - Check the `scriptPubKey`. Does it contain an `addresses` array (or sometimes a single `address` field)?
    - Check if any address listed in `scriptPubKey.addresses` (or `scriptPubKey.address`) exists in the platform's list of managed deposit addresses.
    - **Important:** Be prepared to handle different script types (P2PKH, P2SH, P2WPKH, P2WSH, etc.) as indicated by `scriptPubKey.type` and ensure your address validation logic matches the script type.
3.  If a match is found:
    - Extract the `txid` of the transaction.
    - Extract the `n` (index) of the matched `vout`.
    - Extract the `value` (amount in [Your Coin Unit], usually needs conversion to satoshis or base units).
    - Extract the matched `address`.

### Step 4.4: Recording Potential Deposits

When a relevant output is identified in `block_hash` at `block_height`:

1.  Store the following information in a dedicated processing database or table:
    - `txid`: Transaction ID.
    - `vout_index`: Output index (`n`).
    - `deposit_address`: The matched platform address.
    - `amount`: The value received (in base units/satoshis).
    - `block_hash`: Hash of the block containing the transaction.
    - `block_height`: Height of the block containing the transaction.
    - `received_time`: Timestamp when the block was processed.
    - `confirmations`: Initialize to 1.
    - `status`: Set to 'pending' or 'unconfirmed'.
2.  **Check for Duplicates:** Ensure you don't record the same `txid:vout_index` combination multiple times (e.g., if reprocessing a block).

### Step 4.5: Tracking Confirmations

Our Confirmation Service periodically queries the status of transactions where `status = 'pending'`.

1.  For each pending deposit, calculate its current confirmations, uses the `getrawtransaction <txid> true <blockhash>` and checks the confirmations field.
2.  Update the `confirmations` count in your database for that deposit record.

### Step 4.6: Crediting User Accounts

Continuously monitor the confirmation counts:

1.  Define a required confirmation threshold (`REQUIRED_CONFIRMATIONS`, e.g., 20 for high security, potentially lower based on risk assessment).
2.  Query your processing database for deposits where `status = 'pending'` AND `confirmations >= REQUIRED_CONFIRMATIONS`.
3.  For each such deposit:
    - **Crucially:** Implement locking or use database transactions to ensure atomicity and prevent double-crediting. Check if this specific `txid:vout_index` has _already_ been credited.
    - If not yet credited, update the corresponding user's balance in the main platform database.
    - Update the deposit record's `status` to 'confirmed' or 'credited'.

### Step 4.7: Handling Blockchain Reorganizations (Reorgs)

Reorgs occur when the node switches to a different, longer chain, invalidating previously accepted blocks.

1.  **Detection:** When fetching a new block (`getblock <hash>`), check its `previousblockhash` field. Does it match the hash of the _last_ block you processed?
    - If **yes**, it's a simple append, proceed normally.
    - If **no**, a reorg might have occurred.
2.  **Find Fork Point:** Trace back the `previousblockhash` links from the new block hash and the last processed block hash until you find the common ancestor block.
3.  **Invalidate Orphaned Deposits:** Identify all deposits in your processing database that were recorded in blocks _after_ the common ancestor on the _old_, now orphaned chain. Mark these deposits as 'invalidated' or 'reorged'. **Do NOT automatically reverse credits already issued** â€“ this requires careful manual intervention or specific business logic to handle potential negative balances.
4.  **Reprocess New Chain:** Starting from the block _after_ the common ancestor on the _new_ main chain, re-run the scanning (Step 4.3) and recording (Step 4.4) logic for all blocks up to the new chain tip. This may find the same transactions in different blocks or entirely new transactions.
5.  **Re-evaluate Confirmations:** After reprocessing, update confirmations (Step 4.5) for _all_ pending deposits based on the heights in the _new_ main chain. Proceed with crediting (Step 4.6) as normal based on the updated confirmations.

## 5. Key Node RPC Commands Used

- `getbestblockhash`: Returns the hash of the most recent block in the best valid chain.
- `getblockcount`: Returns the height of the most recent block in the best valid chain.
- `getblock <blockhash> [verbosity=2]`: Retrieves block data. Verbosity 2 provides detailed JSON including decoded transactions.
- `getrawtransaction <txid> [verbose=1]`: (Optional) Can be used to get details for a specific transaction if needed, though `getblock` verbosity 2 usually suffices.
- `scantxoutset`: (Advanced/Alternative) Can scan the UTXO set for specific addresses but is less suitable for continuous monitoring of _new_ deposits than block-by-block scanning. Better for initial checks or recovery.

## 6. Important Considerations

- **Confirmation Threshold:** Choose a threshold (`REQUIRED_CONFIRMATIONS`) that balances security against deposit speed. 6 is common for Bitcoin and forks, but research best practices for fractal.
- **Reorg Depth:** Decide how deep a reorg your system needs to handle robustly. Deeper reorgs are rarer but more disruptive.
- **Idempotency:** The crediting step _must_ be idempotent (running it multiple times for the same deposit has no additional effect after the first successful run) to prevent double-spending/crediting.
- **Database Performance:** Ensure your database can handle the load of storing and querying deposit records, especially confirmation updates. Index relevant columns (`status`, `confirmations`, `txid`, `vout_index`).
- **Node Stability & Security:** Rely on a stable, secure, and non-malicious node connection. Monitor node sync status. Protect RPC credentials.
- **Error Handling:** Implement robust error handling for RPC connection issues, timeouts, invalid responses, etc.
- **Resource Usage:** Repeatedly calling `getblock` can be resource-intensive. Consider ZMQ or batching updates where appropriate.

## 7. Conclusion

Processing deposits for fractal requires careful synchronization with the blockchain, meticulous tracking of transactions and their confirmations, and robust handling of edge cases like reorganizations. By implementing the logic outlined above using the node's RPC interface, platforms can build a reliable and secure deposit system. Always prioritize security and thorough testing.
